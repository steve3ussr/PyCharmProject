也不知道该看啥，就做了 [leetcode cn的最火的一百题](https://leetcode-cn.com/problem-list/2cktkvj/) 。

# 1 two-sum 
给定一个整数数组 nums和一个整数目标值 target，
请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。
你可以按任意顺序返回答案。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/two-sum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

这题本身没什么难度，两次遍历就行，遇到符合条件的就return。但是这是一个时间复杂度为$O(n^2)$的方法，因为两次遍历需要$\frac{n(n+1)}{2}。

为了减小时间复杂度，我的想法是：
1. List - target/2, T(n) = n
2. abs(List), T(n) = 2n
3. sort, O(n) = O(nlogn), 比如归并，build-in sorted使用的Timsort
4. 对每个元素，判断它和下一个元素是否相同，return k, T(n) = 3n + T(sort) **问题一**
5. abs(i - target/2) = k, 对此能找到两个原始的i值;
6. 两次遍历分别查找对应两个i值的index, T(n) = 5n + T(sort)

问题一：假如输入列表中有两个3，但答案不是两个3，那这里有可能会返回3对应的值(5中提到)，查找index时就会报错；
       所以再后面做了校验，

看评论区里一个比较好的方法是用**Hash Table**，但是我不知道这是啥。尽管如此，我的运行时间也在最快的那一批里。
但Hashmap确实香。

# 2 addTwoNumbers

题目描述：



我觉得最大的问题是我已经忘了链表怎么操作了。

思路：
1. 正常情况下：l1 = l1.next
2. 如果l1是最后一个，那next之后就是None
3. 外循环用l1 l2是否为None判断是否结束
4. 如果l1已经是None，那在取值时就返回0

![](https://i.imgur.com/Lhsm4Wn.png)


# 3 lengthOfLongestSubstring

![](https://i.imgur.com/u98iTeq.png)

1. 用hashmap加快速度，减少一个O(n)；
2. win和start代表窗口长度和起始点
3. case1： 新元素不在map中，win++
4. case2：新元素在map中，查找map中重复元素的index
   - 在index >= start的情况下：
     - 减小win
     - 改变start
5. 这两个case必然改变win，在每次循环后取softmax
6. 这两个case之后必然改变map，不管是增加还是修改键值

# 4 findMedianSortedArrays

1. 问题转化为寻找第k小的元素，k>=1
2. 分三种exit情况：列表为空，或者k==1时返回第一个元素的最小值
3. 比较两个列表的第k//2个值，小的一方可排除前k//2个值
4. 3中有可能指针越界，但总的来说要让两个列表中待排除的元素数量a和b之和为k，所以让其中一个为最大值
5. 操他妈的，为什么python build in 的sort最快

# 5 longestPalindrome

![](https://i.imgur.com/N4pCh2H.png)

思路：

1. 从中心向两边推；
2. 记录两边一样的最大臂长
3. 注意：aba和abba是两种情况，因为中心不一定是整数
4. range只能生成整数数列

但是： 这样时间复杂度较大，空间复杂度小

改进：
1. 有left和right两个变量，条件合适的话分别外扩；
2. 对每个i，l，r init 分别为ii和ii+1，代表'aba'和'abba'两种情况

# 6 convert(Z形变换)

![](https://i.imgur.com/AsniBx9.png)

***这是我第一次不看答案就能写出来，而且首次提交就通过的题！*

思路：
1. 结果首先是一个列表，根据行数，分为多个空字符串；
2. k = 2r-2，因为这是一个周期；
3. 按照index的mod k来判断添加到哪个字符串里；
4. 假如r=4，则k=6，一个周期里的数字应该分别放到0,1,2,3,2,1个字符串里，通过判断改变值；
5. `str += v`可以拼接;
6. `''.join(list)`可以把列表里的字符串拼在一起

# 7 reverse

因为限制环境中只能有32位的数字，我的思路是：
1. 先把ans做成str，最后来个int，用try-except改变return的值；
2. 但是py里没有限制，所以用值来判断ans，改变输出——这样其实有问题

正确方法：
1. 通过简单的数学步骤，确定只要imin<=ans<=imax就行，简单的不等式变换；
2. `imin = min//10 + 1`;
3. `imax = max // 10`;

# 10 isMatch 正则匹配

从这个题开始，我才正式看了动态规划是什么，感觉动态规划可以解决很多复杂问题，但是想起来比较难。

动态规划 Dynamic Programming: 
1. 定义一个一维数组，或者二维数组，如`dp[i][j]`,赋予一个物理意义；
2. 找到状态转移方程，比如`dp[i] = dp[i-1] + dp[i-2]`;
3. 给定边界条件，比如`dp[0] = 1`

对这个题来说，难点在于想到各种情况。

可以，也可以不做：把正则表达式里，带不带星号的拆分开，因为带星号和不带星号完全不一样；

我拆开了，因为这样比较好想后面的过程。

`dp[i][j] = bool`，i为字符串长度，j为正则表达式长度，这是物理意义。

1. 如果`p[j]`是普通的，不带星号的话，是`dp[i][j] = dp[i-1][j-1] and T/F`；
这个TF取决于`s[i]p[j]`是否一样； 
2. 如果`p[j]`是带星号的话：
   1. 比如`a, ab*`这种情况，因为`*`可以匹配0个字符，所以这时候是**无匹配**状态，`dp[i][j]=dp[i][j-1]`;
   2. 若果是`abbb,ab*`，属于**有匹配**状态，`dp[i][j]=dp[i-1][j]`;
   3. 上一条最终会变成`a, ab*`;
   4. 但这样有问题，比如`a, ab*a*`, 就会转移到`[], ab*`，最终为False；
   5. 所以应该加上一个`or dp[i][j]=dp[i][j-1]`，因为`a, ab*a*`和`a, ab*`的状态是一样的；
3. 初值的话，因为有i-1，j-1，所以ij定为字符串长度，设要查找的是`dp[m][n]`；
   1. `dp[0][0] == True`;
   2. `dp[0][any] == unkonwn`;
   3. `dp[any][0] == False`;不给正则相当于没法匹配；
   4. `dp[1,2...][1,2...] == Unkonwn`.
4. 循环的话，从m=0,1,2... n=1,2...循环，因为第一列已经确定了。
5. 如何确定是否匹配呢？这个应该能想出来。

难呐，真他妈难。

# 11 maxArea

第二次双指针问题，上一次是滑动窗口，但是我没学双指针。

双指针可分为三种：

1. 快慢指针，快的步进2，慢的步进1，相遇结束，感觉多用于链表；
2. 碰撞指针，左右指针从两头移动，相遇结束，常用于有序数组（但这个题无序也能用）；
   1. 如果是无序的，也可以先排序；
   2. 可以解决2数之和问题；
   3. 3数之和可以变成1个数，和2数之和问题；
3. 滑动窗口，一般是对窗口内的元素进行计算，比如字符串匹配。

思路：
1. 最大体积由左指针和右指针确定，其中一长一短；
2. 如果移动长的一个，那么由于水的高度由短板决定，所以：
   1. 双指针距离一定减小；
   2. 高度一定减小，可能为原先的短板，也可能是更短的；
3. 如果移动短的一个：
   1. 双指针距离一定减小；
   2. 高度可能不变，可能增长，可能减小；
4. 所以**唯一的可能性在移动短的一个**。

操作很简单，循环条件为指针不重合，比较体积。

# 15 threeSum 三数之和

双指针的思路是对的，但是缺少细节。

双指针解决两数之和twoSum：
1. sort排序先；
2. 左指针和右指针在两侧；
3. 求和，看和target的关系：
   1. 如果小于target，说明需要增大，移动左指针；
   2. 如果大于target，说明需要减小，移动右指针；
4. 循环条件：左指针小于右指针，**不是等于，因为偶数个数列会错过**。

解决三数之和threeSum：
1. 外层循环：固定第一个数；
2. 转化为twoSum；

需要注意的点：

1. 外层循环（第一个值）大于0就不用找了；
2. 第一个值和上一组符合条件的第一个数值一样也不用找了，会重复，比如[-3, -3, 1, 2]；
3. 双指针符合target的话，如果分别和第二个、第三个数值一样，continue，如[-3, 0， 0, 1, 2, 3， 3]，并且应该同时移动；
4. 其他的都是满足条件的。

# 17 letterCombinations

这个题没什么可以简化时间复杂度的方法，就是遍历，比如'23'对应O(3x3), '27'对应O(3x4)。

但是遍历也是要讲究方法的，这里用的叫回溯（backtrack）
2 -> abc
3 -> def
![](https://i.imgur.com/mT7S04z.png)

在这里维护一个字符串，如果到了最后一个节点，比如已经是'ad'了，就把'ad'添加到结果，然后回溯到上一个节点，变成'a'。

在这个过程中，字符串的变化是：
1. ''
2. 'a' (这里进入abc的循环,并且往更深处寻找)
3. 'ad' (进入def的循环)
4. 'a' (上一步中已经到头了，，添加到结果，回溯)
5. 'ae' 'a'
6. 'af' 'a'
7. '' (回溯到上一个节点)
8. 'b' 

TIPS：
- `itertools.product()` 可以用一行搞定这个问题； 
- `*` 的作用是拆包，比如`*tuple`
- 
